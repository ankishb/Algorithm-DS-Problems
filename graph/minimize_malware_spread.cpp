
class DisjointSet{
	vector<int> rank;
	vector<int> parent;
	int n;

public:
	DisjointSet(int n_){
		vector<int> temp(n_, 0);
		rank = temp;
		parent = temp;
		n = n_;
		makeset();
	}

	void makeset(){
		for(int i=0; i<n; i++){
			parent[i] = i;
		}
	}

	void print_parent(){
        for(auto itr : parent) cout<<itr<<" ";
		cout<<endl;
	}
    
    void get_data(unordered_map<int, int> &my_map){
        for(auto itr : parent){
            my_map[itr]++;
        }
    }

	int find(int x){
		if(parent[x] != x){
			parent[x] = find(parent[x]);
		}
		return parent[x];
	}

	void union_(int x, int y){
		int x_set = find(x);
		int y_set = find(y);
		// if both element belong to same set
		if(x_set == y_set){
			return ;
		}
		// find rank of them, take union according
		// 1. Choose parent to that set, which have higher rank
		// 2. If rank equal, run path compression algo
		if(rank[x_set] < rank[y_set]){
			parent[x_set] = y_set;
		}
		else if(rank[x_set] > rank[y_set]){
			parent[y_set] = x_set;
		}
		else{
			parent[y_set] = x_set;
			rank[x_set] = rank[x_set]+1;
		}
	}
};


class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    	int n = graph.size();
    	DisjointSet set(n);
    	for(int i=0; i<n; i++){
    		for(int j=0; j<n; j++){
    			if(graph[i][j] == 1){
    				set.union_(i, j);
    			}
    		}
    	}
    	
        unordered_map<int, int> my_map;
    	set.print_parent();
        set.get_data(my_map);
        
        sort(initial.begin(), initial.end());
        int parent, cost_i;
    	int m = initial.size();
    	vector<int> cost(m, 0);
    	for(int i=0; i<m; i++){
    		parent = set.find(initial[i]);
            cost_i = my_map[parent];
            cost[i] = cost_i;
    	}
        
        int ans = INT_MIN;
        int id = 0;
        for(int i=0; i<m; i++){
            if(ans < cost[i]){
                ans = cost[i];
                id = i;
            }
        }  
    	return initial[id];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    	int n = graph.size();
    	vector<int> cost;
    	// set<int> temp;
        int max_cost = 0;
        int max_id=0;
        int max_count;
        for(int i=0; i<n; i++){
            max_count = 0;
        	for(int j=0; j<n; j++){
        		if(i!=j && graph[i][j]==1){
                    cout<<i<<" "<<j<<endl;
                    max_count++;
        		}
        	}
            cominimize_malware_spreadst.push_back(max_count);
        }
        
        for(auto itr : cost) cout<<itr<<" ";
        cout<<endl;
        int m = initial.size();
        max_id = initial[0];
        max_cost = cost[initial[0]];
        for(int i=1; i<m; i++){
            if(cost[initial[i]] > max_cost){
                max_cost = cost[initial[i]];
                max_id = initial[i];
            }
        }
    
    	return max_id;
    }
};