## Difference between subarray and subsequence?
- **Subarray** is the contiguous represent sequence, where as in **subsequence**, sequence can have any arbitrary order.
- For example: In possible combination of [1,2,3] ==> {1,3} is not subarray, it is subsequence.

## What is the difference between a macro and a function in C programming?
The basic difference is that function is compiled and macro is preprocessed. When you use a function call it will be translated into ASM CALL with all these stack operations to pass parameters and return values. When you use a MACRO, C preprocessor will translate all strings using macro and then compile.

In C (and C++) a macro is a preprocessor directive. This means that before your program starts compiling it will go through and process all your macros.

## Difference between template and macros?
Templates cause code substitution, but obey a certain set of rules. That means that the compiler checks types before creating the new class/object. Macro are parsed by the Pre-processor, which only replaces text.

So, templates will always take longer to process. The code generated by the Macro, however, can take a certain time to process.


## Advantage of C++ (OOP)?
- Classes: Class is a blueprint of data and functions or methods. Class does not take any space.
- Class is a user defined data type like structures and unions in C.
There are four pillars of OOP, which are
1. Encapsulation(wrapping of everything in a packet(class))
2. Data Abstraction(display only, what world need to see, there are access modifiers: public, private or protect to do this job)
3. Polymorphism(don't repeat code for each data type, use template)
4. Inheritance(Inherit base class in other classes, there are function overloading, to edit the existed function)

## Encapsulation: 
- Wrapping of data and functions into a single unit. 
- The data is not accessible to the outside world and only those functions which are wrapping in the class can access it. 
- It is called data hiding or `information hiding`.

## Data abstraction:
- provide only needed information to the outside world and `hiding implementation` details. 
- We have access modifiers: public, private and protect to do this job

## Inheritance: 
- inheritance is the process by which objects of one class acquire the properties of objects of another class. 
- It provides re usability. This means that we can add additional features to an existing class without modifying it.



## Polymorphism: 
- polymorphism means ability to take more than one form. 
- An operation may exhibit different behaviors in different instances. The behavior depends upon the types of data used in the operation.
- C++ supports operator overloading and function overloading.
    - The process of making an operator to exhibit different behaviors in different instances is known as `operator overloading`.
    - `Function overloading` is using a single function name to perform different types of tasks.



## Dynamic Binding: 
In dynamic binding, the code to be executed in response to function call is decided at runtime. C++ has virtual functions to support this.



Message Passing: Objects communicate with one another by sending and receiving information to each other. A message for an object is a request for execution of a procedure and therefore will invoke a function in the receiving object that generates the desired results. Message passing involves specifying the name of the object, the name of the function and the information to be sent.



## Access Modifiers:
- Main purpose is **Data Hiding**.
- Access modifiers or Access Specifiers in a class are used to set the accessibility of the class members. That is, it sets some restrictions on the class members not to get directly accessed by the outside functions.

There are 3 types of access modifiers available in C++:
1. Public
2. Private
3. Protected

> Note: By default the access modifier is Private.

Let us now look at each one these access modifiers in details:
### Public: 
- All the class members declared under public will be available to everyone. 
- The data members and member functions declared public can be accessed by other classes too. 
- The public members of a class can be accessed from anywhere in the program using the direct member access operator (.) with the object of that class.

### Private: 
- The class members declared as private can be accessed `only by the functions inside the class`. 
- They are not allowed to be accessed directly by any object or function outside the class. 
- Only the member functions or the `friend functions` are allowed to access the private data members of a class.
Example:
```c++
class Circle {    
// private data member 
private:  
    double radius; 
   
// public member function     
public:     
    double  compute_area(){   
    // member function can access private data member radius 
        return 3.14*radius*radius; 
    } 
}; 
  
// main function 
int main() 
{    
    Circle obj; 
      
    // trying to access private data member directly outside the class 
    obj.radius = 1.5; //raise compile time error
    cout << "Area is:" << obj.compute_area(); 
    return 0; 
} 
```

However, we can access the private data members of a class indirectly using the public member functions of the class. Below program explains how to do this:
```c++
class Circle 
{    
private:  
    double radius; 
public:     
    void compute_area(double r) {   
        // member function can access private  
        radius = r; 
        double area = 3.14*radius*radius; 
          
        cout << "Radius is:" << radius << endl; 
        cout << "Area is: " << area; 
    } 
}; 

int main() 
{    
    Circle obj; 
    obj.compute_area(1.5); 
    return 0; 
} 
```

### Protected: 
- `Protected are inaccessible outside the class`
- they can be accessed by any subclass(derived class) of that class.
- Similar bahaviour as that of private access modifier except above one case

---

## Constructor:
### What is constructor?
- A constructor is a member function of a class which initializes objects of a class. 
- In C++, they are automatically called when object(instance of class) create. It is special member function of the class.

### How constructors are different from a normal member function?
A constructor is different from normal functions in following ways:
1. Constructor has same name as the class itself
2. Constructors don’t have return type
3. A constructor is automatically called when an object is created.
4. If we do not specify a constructor, C++ compiler generates a default constructor for us (expects no parameters and has an empty body).

### Types of Constructors
#### `Default Constructors`: 
- It doesn’t take any argument.

> Note: Even if we do not define any constructor explicitly, the compiler will automatically provide a default constructor implicitly.

#### Parameterized Constructors: 
- It is possible to pass arguments to constructors. Typically, these arguments help initialize an object when it is created. To create a parameterized constructor, simply add parameters to it the way you would to any other function. When you define the constructor’s body, use the parameters to initialize the object

Uses of Parameterized constructor:
1. It is used to initialize the various data elements of different objects with different values when they are created.
2. `It is used to overload constructors.`

> we can have more than one constructors in a class as well. This is `Constructor Overloading`.

## Copy Constructor:
Copy Constructor: A copy constructor is a member function which initializes an object using another object of the same class. Detailed article on Copy Constructor.

```c++
class Point { 
private: 
    int x, y; 
public: 
    Point(int x1, int y1) { 
        x = x1; 
        y = y1;
    } 
    // Copy constructor 
    Point(const Point &p2) {
        x = p2.x; 
        y = p2.y; 
    } 
}; 
  
int main() 
{ 
    Point p1(10, 15); // Normal constructor is called here 
    Point p2 = p1; // Copy constructor is called here 
    return 0; 
}
```

When is copy constructor called?
In C++, a Copy Constructor may be called in following cases:
1. When an object of the class is returned by value.
2. When an object of the class is passed (to a function) by value as an argument.
3. When an object is constructed based on another object of the same class.
4. When the compiler generates a temporary object.

It is, however, not guaranteed that a copy constructor will be called in all these cases, because the C++ Standard allows the compiler to optimize the copy away in certain cases, one example is the return value optimization (sometimes referred to as RVO).

> By default all members of a class are private. Since no access specifier is there for Point(), it becomes private and it is called outside the class when t1 is constructed in main. 


## Difference between pre and post increment:


You hit the nail on the head. Your understanding is correct. The difference between pre and post increment expressions is just like it sounds. Pre-incrementation means the variable is incremented before the expression is set or evaluated. Post-incrementation means the expression is set or evaluated, and then the variable is altered. It's easy to think of it as a two step process.

b = x++;

is really:

b = x;
x++;

and

b = ++x;

is really:

x++;
b = x;



## Operator overloading:
In C++, We can have more than one constructor in a class with same name, as long as each has a different list of arguments.This concept is known as Constructor Overloading and is quite similar to function overloading.

    Overloaded constructors essentially have the same name (name of the class) and different number of arguments.
    A constructor is called depending upon the number and type of arguments passed.
    While creating the object, arguments must be passed to let compiler know, which constructor needs to be called.




## Structure:
- Assignment is allowed in c
- **no logical operation can be done**
```c++
struct book{
    char title[100];
    int total_page;
};

struct book b1;
struct book b2 = {"GOT", 100};
struct book b_arr[2] = {{"GOT1", 100}, {"GOT2", 200}};
b1 = b2; //valid
if(b1 != b2) // invalid
```

## Swapping:
- vector swapping is done in **O(1)**, whereas element wise swapping takes **O(n)** time.
- ```cpp vect1.swap(vect2)``` it swaps complete vector with the other vector with the same type and size.
- 

## Set in STL:
- it is a container (**not vector**)
- with no duplicates
- data in lexical order
- For insertion, use **set_name.insert(data)**
- **find an element in O(n)** instead of **O(n)** in another container.
- Example: **how to detect, if insertion is success or failute**.
- std::set returns std::pair<iterator, bool>, where the bool is false when the insertion failed (by adding duplicate values for example).

``` c++
std::set<int> set{ 1, 2, 3 };
auto result = set.insert(1);
if (!result.second)
    std::cout << "Failed to insert element!" << std::endl;
```

## How to return data from the recurive function:
- Send a vector or container to function, it recusivly put some data in container, **but we need to pass it as reference using &vect_name**
```c++
void get_permutation(string str, vector<string> &ans){
    if(condition){
        ans.push_back(data);
    }
    //some operation
}

get_permutation(str, container_);
```


## Time complexity Analysis:
- Big-Oh notation: O(g(n)): Give us upper bound, which means, there exist a constant **c** and **no**, such that f(n) <= g(n) for all **n>no**, Graphically, after a point **no**, the function cg(n) will cross the function f(n), which act as upper bound.
- Omega notation: Give us lower bound, there exist a number, such that after that point, the function never cross the omega(g(n))
- Theta Notation: which gives a tight bound of function.
- For example: our algo has T(n) = 5n*n+3n+1, upper bound can be specified by 8n*n and lower bound as n*n.

### Imp points to remember to analyze time complexity:
- very large input size
- worst case scenario
-- drop lower order term
-- drop constant 2N*N ==> N*N



Algorithm           Time Complexity
--------------------------------------------------------
|                | Best         |  Average    |  Worst |
--------------------------------------------------------
| Selection Sort | Ω(n^2)       | θ(n^2)      |  O(n^2)
| Bubble Sort    | Ω(n)         | θ(n^2)      |  O(n^2)
| Insertion Sort | Ω(n)         | θ(n^2)      |  O(n^2)
| Heap Sort      | Ω(n log(n))  | θ(n log(n)) |  O(n log(n))
| Quick Sort     | Ω(n log(n))  | θ(n log(n)) |  O(n^2)
| Merge Sort     | Ω(n log(n))  | θ(n log(n)) |  O(n log(n))
| Bucket Sort    | Ω(n+k)       | θ(n+k)      |  O(n^2)
| Radix Sort     | Ω(nk)        | θ(nk)       |  O(nk)
--------------------------------------------------------

## Tree Based Method:
- Binary Tree:
-----------------------------------
|           | General    |  Worst |
-----------------------------------
| Insertion |   Ω(n)     | θ(n)   |
| Deletion  |   Ω(n)     | θ(n)   |
| Search    |   Ω(n)     | θ(n)   |
-----------------------------------
- Binary Search Tree:
-----------------------------------
|           | General    |  Worst |
-----------------------------------
| Insertion | Ω(h)       | θ(n)   |
| Deletion  | Ω(h)       | θ(n)   |
| Search    | Ω(h)       | θ(n)   |
-----------------------------------
- AVL/Height Balanced Tree
-----------------------------------
|           | General   |  Worst |
-----------------------------------
| Insertion | Ω(log2n)  | θ(log2n) |
| Deletion  | Ω(log2n)  | θ(log2n) |
| Search    | Ω(log2n)  | θ(log2n) |
------------------------------------

## Resizing Strategy in stack (optimization of capacity of array)
The resize()\verb#resize()#resize() method is called only when the size of the stack is a power of 2. There are ∼log2⁡n powers of 2 between 1 and n.

## Cycle Detection in Directed/Undirected Graph:
- In directed Graph, there is single link for each node as **u-->v**.
- In Undirected Graph, there is doubly link for each node as **u-->v && v-->v**, therefore, while checking whether the node is already visited or not, we need to consider following conidition, that the **node should not be parent of the other node, which means, the edge we are checking should not be u-->v**, it can be sth like **u-->w-->v-->u**.


## Data Types:
Data Type           Size (in bytes)     Range
short int               2           -32,768 to 32,767
unsigned short int      2           0 to 65,535
unsigned int            4           0 to 4,294,967,295
int                     4           -2,147,483,648 to 2,147,483,647
long int                4           -2,147,483,648 to 2,147,483,647
unsigned long int       4           0 to 4,294,967,295
long long int           8           -(2^63) to (2^63)-1
unsigned long long int  8           0 to 18,446,744,073,709,551,615
signed char             1           -128 to 127
unsigned char           1           0 to 255
float                   4
double                  8
long double             12
wchar_t                 2 or 4          1 wide character

## Pointers:
- watch mycodeschool video lecture or checkout **Pointer_tutorial.cpp** file

## Genereic pointer type
- void pointer
- it doesn't map to any particuylar data type
- we can not dereference of void pointer.

## Lower and Upper Bound:
- It find the range of value as **[low, high)**, note that, high is excluded, so if you want to find the range of value in the array, it will be **[lower_bound, upper_bound-1]**.
```c++
int low, high;
high = upper_bound(A.begin(), A.end(), B) - A.begin();
// cout<<high;
if(A[high-1] != B){
    vector<int> vect{-1, -1};
    return vect;
}
low  = lower_bound(A.begin(), A.end(), B) - A.begin();
vector<int> vect{low, high-1};
return vect;
```

## Upper Bound:
- Index of element just greater than value.
- **For exp: [10,20,20,30], for 20 or 25, upper bound is 3.**
- It returns an iterator pointing to the first element in the range [first, last) that is greater than value, or last if no such element is found. The elements in the range shall already be sorted or at least partitioned with respect to val.

## 2d Vector initialization:
- **Method 1**:
```c++
vector<vector<int>> array_2d(rows, vector<int>(cols, 0));
// now access variable as follows:
cin>>array_2d[i][j];
```

```c++ 
vector<vector<int>> array_2d(rows);
// This is empty vector, just push element in the 2D vector as simple
vect[1].push_back(2); 
```

## Why we can't access the size of the array from the function?
- Just imagine a stack, where it store all local/global variables. Now in that stack, we already have an stored array in **main** function. After calling to function, it will create all the local varaible again, **Beautiful Part**, if we copy the entire data/array again, it is memory as well as time inefficient. So to avoid this, it **creates an pointer to that array and out statement int arr[] become int *arr that is deferencing the pointer**, and that is accessed by the function.**

## (A+i) is same as &A[i]
## *(A+i) is same as A[i]

## Iterator: (anagramic pair of string_array)
- pairs can be accessed in two ways: **(*it).first** or **it->first****
```c++
// method1
unordered_map<int, vector<int> > map_;
for(auto it=map_.begin(); it!=map_.end(); ++it){
    cout<<endl<<it->first<<" -> ";
    for(auto it2=(it->second).begin(); it2!=(it->second).end(); ++it2){
        cout<<*it2<<" ";
    }
}

// method2
for(auto it=map_.begin(); it!=map_.end(); ++it){
    cout<<endl<<(*it).first<<" -> ";
    for(auto it2=((*it).second).begin(); it2!=((*it).second).end(); ++it2){
        cout<<*it2<<" ";
    }
}
```

## Difference between string and string-stream:
```c++
string s2 = "Dragon Land";
s1.assign(s2);          // Dragon Land
s1.assign(s2, 2, 4);    // agon         | this is string
s2.assign("Window");    // Window
s2.assign("Window", 4); // Wind         | this is string-stream, where it takes size of string to init, rather than the pointer to position first.

s1.assign(4, 's');      // ssss
s1.append(" oye");      // ssss oye
s1.insert(2, " ankish ", 4)// ss ankssss oye
s1.replace(pos, size, with_whom, pos, size);
s1.replace(2, 5, s2, 3, 3); // abgn oye
s1.erase(pos, size);
s2.substr(pos, size);

```

## Pointer in struct node:
- when we create a new node, it will create an pointer which point to a node, with defined data space of struct node.
- At start head is pointing to NULL. When we create new node and fill data in it, let's say it is temp_node, we can directly do **head = temp_node**, which saves the temp_node pointer address in the head node pointer.

## Q: What is the space taken by initializing a node in tree?

## Amotized Analysis:
- It analyse the worst-case run time per operation, rather than per algorithm, can be too pessimistic.
- For example, inserting an N element in vector, takes O(n) time, but O(1), for inserting a single element.

## Dynamic Programming:
The idea is very simple, If you have solved a problem with the given input, then save the result for future reference, so as to avoid solving the same problem again.. shortly ‘Remember your Past’. If the given problem can be broken up in to smaller sub-problems and these smaller subproblems are in turn divided in to still-smaller ones, and in this process, if you observe some overlapping subproblems, then its a big hint for DP. Also, the optimal solutions to the subproblems contribute to the optimal solution of the given problem


## [set_precision_of_double] [look in c++ tutorial file]
```c++


#include <iomanip>
#include <iostream>

int main()
{
    double num1 = 3.12345678;
    std::cout << std::fixed << std::showpoint;
    std::cout << std::setprecision(2);
    std::cout << num1 << std::endl;
    return 0;
}

```


## Difference between endl vs '\n':
- endl is exacly do what '\n' do for us, but it also do one extra operation `flush`.
- '\n' takes one byte, because it is a character, but endl doesn't need any memory.
- `flush` operation is done by calling an OS to flush the data.

## How buffer works in c++?
- Consider writing to a file. This is an expensive operation. If in your code you write one byte at a time, then each write of a byte is going to be very costly. So a common way to improve performance is to store the data that you are writing in a temporary buffer. Only when there is a lot of data is the buffer written to the file. By postponing the writes, and writing a large block in one go, performance is improved.

- **With this in mind, flushing the buffer is the act of transferring the data from the buffer to the file.**

## Why to use **const** while writing an customize operator like comparator for sorting.
- It is passing by refernce operator.
- Let's say you have an vector of 1000 element, if we don't use pass by reference, which will copy the current element in local variable and operate the operation. Which is time consuming, as of storing the variable.



## A important theorm:
- **if i1 < i2 && j1 < j2, then max(|i1 - j1|, |i2 - j2|) <= max(|i1 - j2|, |i2 - j1|)**

## Greedy Algorithm Vs Dynamic Programming

Feature | Greedy method | Dynamic programming
---- | --- | --- 
Feasibility | In a greedy Algorithm, we make whatever choice seems best at the moment in the hope that it will lead to global optimal solution. | In Dynamic Programming we make decision at each step considering current problem and solution to previously solved sub probelm to calculate optimal solution .
Optimality | In Greedy Method, sometimes there is no such guarantee of getting Optimal Solution. | It is guaranteed that Dynamic Programming will generate an optimal solution as it generally considers all possible cases and then choose the best.
Recursion | A greedy method follows the problem solving heuristic of making the locally optimal choice at each stage. | A Dynamic programming is an algorithmic technique which is usually based on a recurrent formula that uses some previously calculated states.
Memorization | It is more efficient in terms of memory as it never look back or revise previous choices | It requires dp table for memorization and it increases it’s memory complexity.
Time complexity | Greedy methods are generally faster. For example, Dijkstra’s shortest path algorithm takes O(ELogV + VLogV) time.   Dynamic Programming is generally slower. For example, Bellman Ford algorithm takes O(VE) time.
Fashion | The greedy method computes its solution by making its choices in a serial forward fashion, never looking back or revising previous choices. | Dynamic programming computes its solution bottom up or top down by synthesizing them from smaller optimal sub solutions.
Example | Fractional knapsack | 0/1 knapsack problem



Greed algorithm : Greedy algorithm is one which finds the feasible solution at every stage with the hope of finding global optimum solution.

Dynamic Programming : Dynamic programming is one which breaks up the problem into series of overlapping sub-problems.

Difference between greedy method and dynamic programming are given below :

    Greedy algorithm is one which finds feasible solution at every stage with the hope of finding optimal solution whereas Dynamic programming is one which break the problems into series of overlapping sub-problems.
    Greedy algorithm never reconsiders its choices whereas Dynamic programming may consider the previous state.
    Greedy algorithm is less efficient whereas Dynamic programming is more efficient.
    Greedy algorithm have a local choice of the sub-problems whereas Dynamic programming would solve the all sub-problems and then select one that would lead to an optimal solution.
    Greedy algorithm take decision in one time whereas Dynamic programming take decision at every stage.
    Greedy algorithm work based on choice property whereas Dynamic programming work based on principle of optimality.
    Greedy algorithm follows the top-down strategy whereas Dynamic programming follows the bottom-up strategy



## Inheritance:
- `class Daughter: protected Mother;` the protected keyword, tells the inheritance level, in this case, all the members will be inherited from Mother either they are `public` or `protected` as `protected`. **Note that `private` members cann't be inherited in any child class.**

What is inherited from the base class?
In principle, a publicly derived class inherits access to every member of a base class except:
    1.  constructors and its destructor
    2. its assignment operator members (operator=)
    3. its friends
    4. its private members **I doubt it**

Access | public | protected | private
--- | --- | --- | ---
members of the same class | yes | yes | yes
members of derived class | yes | yes | no

---

## Intersting:
- class object cann't accessed, if they are initialized in if statement, because there scope is limited only in that conditional statemnt parenthesis. One way to go is that

```
Report header;

if (...) {
  header = Report();
else
  header = Report(name,company);

------------------------------------------------
Or in a shorter way:

Report header; // calls default constructor

if (shouldInitializeWithParams) {
  header = Report(name,company);
}
```




## Types of Inheritance:
- single inheitance
- multilevel inheritance
    india
     ||
    Asia
     ||
    World
- Multiple Inheritance
          Bird
      /        \
    sparrow   parrot
- Hierarchical
            world
        /           \
    india           USA
    /    \          /   \
- Hybrid:
    - **Hierarchical + Multiple**
         class A
     /      |     \
class B     |     Class D
       \    |   /
        class C
    - **Multiple + multilevel**





## sizeof()
limit.h
float.h

## Enum DataType
- Syntax: `enum boolean {NO, YES}`;
- By default it start with 0 for these variable
- Syntax `enum months {Jan=1, Feb, Mar, Apr}`;
- Usuage in `Better readability of code` for exp `month==2`, can be misleading where as `month==Feb`, make more sense
- #define No 0
- enumeration has a scoping rule, where hash define doesn't. That's why enum is prefered
- Also in #define, we need to declare each element separately, where enum has property to assign value in increasing order.


## Constant DataType
- int: 1234
- long int: 1234l
- float: 12.34
- octal: 037 `number starting with 0` ie 3*8 + 7
- hexadeciaml: 0x12: `number starting with 0x`
- long octal: 0x12l `last digit is L`
- character: `x`

`const float pi = 3.14` or `#define pi 3.14`
- #define is faster, as it will replace the keyword `pi` with `3.14` where as in other case, it has to go to address of variable to fill the value



## Increment (pre and post):
- `++i`: increment n before its value is used
- `i++` increment n after the value is used
- for exp: `x = 10; y = x++; z = ++x`, their result  will be `y = 10 and z = 12`
- `y = x++` is equivalent to `y = x, x += 1`. Similarly `z = ++x` is equivalent to `x += 1, z = x`
- So x is increment twice, before assigning it to `z`

## Operator
- `!` not gate
- `~` complement (~0110 = 1001)
- `&` exclusive and
- `^` bitwise explisive or
- `|` inclusive or
- `&&` logical and (condition check)
- `||` normal OR (logical)


## Storage Management:
- there are `4` sections, stack(local variable and functions), heap(dynamic memory allocation unit for variables), static and global variable, text.
- static and global variable are init by 0 (`Default`)
- local variable are init randomly.
- static variable are only init once, even we explicity declare initailization, it won't be init again.
- malloc/calloc allocates memory in **continuous blocks**. if there is no enough memory of block, it will return `NULL`.
- if also store one more bytes along with given allocated space. This extra byte store the `container size`, which is used by `free` function to free the memory space.
- realloc will reassign the memory again with the given size, it will expand the block if available, otherwise it will copy the data from previous memory to new one. For exp, we create array of 5 bytes, now we reallocates to  10 bytes. it space available, it will expand, otherwise it find 10 bytes space and copy data there.
- malloc syntax: `int *p = (int*) malloc(sizeof(int))` (int*) is type casting, sizeof(int) will be system dependent, it will assign a block of memory of size interger

```
int main()
{
    static i = 5
    if(--i){
        main();
        cout<<i<<" ";
    }
}
Output:
0 0 0 0
```


## How malloc works
- it call system node, to ask for free memory block, it will ask for some big chunk of memory not that what we ask it to
- it chops that chunk and return us the desired space. 
- if you ask for larger block, if it already has that, then it return, otherwise it will again call system to ask for memory.
- it use linked list to maintain these block of memory.
- while assigning a memory, it use `first-fit` method, (can read more about in operating system).


## structure
- no space is allocated by declaring struct
- assign memory while initailized or feeding data
- struct name call tag, which is used to call
- self refrential structure in some ds, we use it(tree, list), to create new nodes inside a node of same type
```
struct node
{
    int value;
    struct node *next;
}
```

- 
```
struct
{
    int a;
}a, y, z;
```
- better
```
struct tagName
{
    int a;
    char x;
};
struct tag1 = {1, 'd'};
struct tag2, tag2;
tag1.a = 10;
```



## Upper Bound: [1,2,4,5], 3 ==> index=2, value=4
- Logic: 
    If A[mid] is greater or equal, just stay there
    if A[mid] is smaller, move leftn pointer to mid+1


## Lower Bound: [1,2,4,5], 3 ==> index=1, value=2
- Logic: 
    If A[mid] is greater, move right pointer to mid-1
    if A[mid] is smaller or equal, just stay there


## Virtual Class:
- Also called as dynamic polymorphism or runtime polymorphism
- It is member function which is defined within base class and then redefined in derived class.
- when we refer to derived class using pointer or reference to class, we can call virtual function for that object.
```c++
class base{
public:
    virtual void print(){ cout<<"base class"; }
};
class derived : public base{
public:
    void print(){cout<<"derived class"; }
};

int main(){
    base *b; //base class pointer
    derived d; //object of class
    b = &d
    b->print(); //output: derived class
}

int main(){
    base *bptr; //base class pointer
    base b; //base class object
    derived d; //object of class
    bptr = &b; //reference to base class
    bptr->print(); // Output: base class
    bptr = &d; //reference to derived class
    bptr->print(); // Output: derived class
}
```

#### Main Rule to use virtual function:
1. They can be accesed only object pointer
2. It can be friend of other function
3. It must be member of same class
4. They cann't be static member
5. It can be friend of other function
6. It must be defined in base class
7. We don't have vitual constructor, but virtual deconstructor is possible.



## New/ delete operator
- var can't be deleted/free once done
- can't free/delete, if new is not used yet
- new ptr is returned, if memory is not available
```c++
int *a = new int;
*a = 200;
cout<<a;
delete a;

or 
int *a = new int(200);
```




## Why is Binary Heap Preferred over BST for Priority Queue?

A typical Priority Queue requires following operations to be efficient.

    Get Top Priority Element (Get minimum or maximum)
    Insert an element
    Remove top priority element
    Decrease Key

A Binary Heap supports above operations with following time complexities:

    O(1)
    O(Logn)
    O(Logn)
    O(Logn)

heapvsbst


A Self Balancing Binary Search Tree like AVL Tree, Red-Black Tree, etc can also support above operations with same time complexities.

    Finding minimum and maximum are not naturally O(1), but can be easily implemented in O(1) by keeping an extra pointer to minimum or maximum and updating the pointer with insertion and deletion if required. With deletion we can update by finding inorder predecessor or successor.
    Inserting an element is naturally O(Logn)
    Removing maximum or minimum are also O(Logn)
    Decrease key can be done in O(Logn) by doing a deletion followed by insertion. See this for details.

So why is Binary Heap Preferred for Priority Queue?

    Since Binary Heap is implemented using arrays, there is always better locality of reference and operations are more cache friendly.
    Although operations are of same time complexity, constants in Binary Search Tree are higher.
    We can build a Binary Heap in O(n) time. Self Balancing BSTs require O(nLogn) time to construct.
    Binary Heap doesn’t require extra space for pointers.
    Binary Heap is easier to implement.
    There are variations of Binary Heap like Fibonacci Heap that can support insert and decrease-key in Θ(1) time

Is Binary Heap always better?
Although Binary Heap is for Priority Queue, BSTs have their own advantages and the list of advantages is in-fact bigger compared to binary heap.

    Searching an element in self-balancing BST is O(Logn) which is O(n) in Binary Heap.
    We can print all elements of BST in sorted order in O(n) time, but Binary Heap requires O(nLogn) time.
    Floor and ceil can be found in O(Logn) time.
    K’th largest/smallest element be found in O(Logn) time by augmenting tree with an additional field.
